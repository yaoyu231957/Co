# CPU设计文档

## 构造

![image-20231121224524298](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20231121224524298.png)

## 结构设计

### 数据通路

> #### 总流水线阶段
>
> | 阶段                  | 简称 | 功能概述                                               |
> | --------------------- | ---- | ------------------------------------------------------ |
> | 取指阶段（Fetch）     | F    | 从指令存储器中读取指令                                 |
> | 译码阶段（Decode）    | D    | 从寄存器文件中读取源操作数并对指令译码以便得到控制信号 |
> | 执行阶段（Execute）   | E    | 使用 ALU 执行计算                                      |
> | 存储阶段（Memory）    | M    | 读或写数据存储器                                       |
> | 写回阶段（Writeback） | W    | 将结果写回到寄存器文件                                 |
>
> #### 取指阶段（Fetch）
>
> - PC
> - NPC
> - IM
>
> #### IF/ID寄存器
>
> #### 译码阶段（Decode）
>
> - GRF
> - EXT
>
> #### ID/EX寄存器
>
> #### 执行阶段（Execute）
>
> - ALU
>
> #### EX/MEM寄存器
>
> #### 存储阶段（Memory）
>
> - DM
>
> #### MEM/WB寄存器
>
> #### 写回阶段（Writeback）
>
> - GRF



#### 指令过程详情

|               | 取指阶段（Fetch）                              | IF/ID寄存器 | 译码阶段（Decode）                                           | ID/EX寄存器                                   | 执行阶段（Execute）                  | EX/MEM寄存器                         | 存储阶段（Memory）                      | MEM/WB寄存器                         | 写回阶段（Writeback）                                 |
| ------------- | ---------------------------------------------- | ----------- | ------------------------------------------------------------ | --------------------------------------------- | ------------------------------------ | ------------------------------------ | --------------------------------------- | ------------------------------------ | ----------------------------------------------------- |
| R型指令       | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 根据相应寄存器 rs、rt 地址获取其中数据                       | 存入rs,rt数据，rd地址                         | ALU 计算                             | 存入ALU计算结果，rd地址              | 无                                      | 存入ALU计算结果，rd地址              | 根据rd 地址与 WD（ALUout），将相应数据写入 rd 中      |
| I型指令       | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 获取rs数据,将指令低 16 位取出经过 EXT扩展（Shift移位）       | 存入rs数据,rt地址，EXT扩展（Shift移位）后结果 | ALU 计算（无）                       | 存入ALU计算（Shift移位）结果，rt地址 | 无                                      | 存入ALU计算（Shift移位）结果，rt地址 | 根据rt 地址与 WD（ALUout/Shift），将相应数据写入 rt中 |
| Lw            | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 获取rs数据,将指令低 16 位取出经过 EXT扩展                    | 存入rs数据,rt地址，EXT扩展后结果              | 通过 rs 寄存器的数据与立即数计算地址 | 存入ALU计算结果，rt地址              | 根据 ALU 计算出的地址仿存               | 存入DM取值结果，rt地址               | 根据rt 地址与 WD（DMout），将相应数据写入 rt中        |
| Sw            | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 获取rs数据,将指令低 16 位取出经过 EXT扩展                    | 存入rs,rt数据,EXT扩展后结果                   | 通过 rs 寄存器的数据与立即数计算地址 | 存入ALU计算结果，rt数据              | 将 rt 寄存器的数据写入 ALU 计算出的地址 | 无                                   | 无                                                    |
| 跳转 B 型指令 | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 比较读取出的 rs 和 rt 寄存器的数据，若相等，则通过多选器将拓展后的立即数作为下一周期的 PC 写入 PC 寄存器 | 无                                            | 无                                   | 无                                   | 无                                      | 无                                   | 无                                                    |
| 跳转 J 型指令 | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 通过多选器将拓展后的立即数作为下一周期的 PC 写入             | 存入PC + 8                                    | 无                                   | 存入PC + 8                           | 无                                      | 存入PC + 8                           | 将跳转前的 PC + 8 写入 31 号 ra 寄存器                |
| 跳转 R 型指令 | 从 PC 寄存器取地址，根据地址从 IM 获得指令编码 | 存入指令    | 通过多选器将 rs 寄存器的数据作为下一周期的 PC 写入           | 无                                            | 无                                   | 无                                   | 无                                      | 无                                   | 无                                                    |



### 译码器

- #### 控制器

  | **funct**           | 100000    | 100010  | --------- | ---------    | --------- | --------- | --------- | --------- | 001000 | --------- |
  | ------------------- | --------- | ------- | --------- | ------------ | --------- | --------- | --------- | --------- | ------ | --------- |
  | **opcode**          | 000000    | 000000  | 001101    | 100011       | 101011    | 000100    | 001111    | 000011    | 000000 | --------- |
  |                     | add       | sub     | ori       | lw           | sw        | beq       | lui       | jal       | jr     | nop       |
  | Wreg_sel (RegDst)   | 01(Rd)    | 01      | 00(Rt)    | 00           | 00        | x         | 00        | 10(Reg31) | 00     | x         |
  | Wdata_sel(MemtoReg) | 00(ALU)   | 00      | 00        | 01(DM)       | 01        | x         | 10(Shift) | 11(Adder) | 00     | x         |
  | W_en (RegWrite)     | 1         | 1       | 1         | 1            | 0         | 0         | 1         | 1         | 0      | 0         |
  | ALUOp               | 010(加)   | 110(减) | 001(或)   | 010(加)      | 010(加)   | 110(减)   | x         | x         | x      | x         |
  | ALUin_sel (ALUsrc)  | 0(Rdata2) | 0       | 1(EXT)    | 1            | 1         | 0         | x         | x         | x      | x         |
  | MemWrite            | 0         | 0       | 0         | 0            | 1         | 0         | 0         | x         | x      | x         |
  | Branch              | 0         | 0       | 0         | 0            | 0         | 1(beq)    | 0         | 2(jal)    | 3(jr)  | x         |
  | EXT_sel             | x         | x       | 01(0扩展) | 00(符号扩展) | 00        | 00        | 00        | 00        | x      | x         |
  | Shift_sel           | x         | x       | x         | x            | x         | 0         | 1         | x         | x      | x         |

### 冒险

- #### 类型

> #### 结构冒险
>
> - 不同指令同时需要使用同一资源
>
> #### 控制冒险
>
> - 分支指令（如 beq ）的判断结果会影响接下来指令的执行流
>
> #### 数据冒险
>
> - 后面指令需求的数据，正好就是前面指令供给的数据，而后面指令在需要使用数据时，前面供给的数据还没有存入寄存器堆，从而导致后面的指令不能正常地读取到正确的数据

- #### 	解决办法

  > #### 阻塞
  >
  > - 在 D 级阻塞的时候，像下一流水级传递的指令不应当是 D 级指令，否则 D 级指令还是会向下一流水级传递。所以我们应当插入“指令气泡（bubble）”，也就是 nop 空指令来避免这种情况。实现 CPU 流水级的“空转”
  >
  > #### 提前分支判断
  >
  > - 将分支判断提前到 D 级
  >
  > #### 延迟槽
  >
  > - 延迟槽是基本上不需要实现的，也就是说，只要不考虑 F 级指令的作废问题，就是实现了延迟槽。唯一需要变更的是，**对于 jal 指令，应当向 31 号寄存器写入 D_PC + 8 或者 F_PC + 4（当 jal 指令在 D 级时）**
  >
  > #### 转发
  >
  > - 数据并非一定要等到写入寄存器堆中才可以被使用，直接从后面的流水级的供给者把计算结果发送到前面流水级的需求者来引用
  >
  > - **AT 法**
  >
  >   - **A模型**
  >
  >     A 模型描述的是一个很显然的事情，就是需求者和供给者转发的数据必须是同一个寄存器的值。
  >
  >     我们的 A 指 Address，也就是**寄存器的地址**（编号）。在转发的时候需要检验需求者和供给者的对应的 A值是否相等，且不为 0.
  >
  >   - **T模型**
  >
  >     **需求时间-供给时间模型**
  >
  >     对于某一个指令的某一个数据需求，我们定义**需求时间 T*use***为：这条指令**位于 D 级的时候**，再经过多少个时钟周期就必须要使用相应的数据。
  >
  >
  >     Tuse的两条性质：
  >                
  >     - Tuse是一个定值，每个指令的Tuse 是一定的；
  >     - 一个指令可以有两个Tuse 值。
  >                
  >     对于某个指令的数据产出，我们定义供给时间Tnew 为：位于某个流水级的某个指令，它经过多少个时钟周期可以算出结果并且存储到流水级寄存器。
  >                
  >     Tnew的两条性质：
  >                
  >     - Tnew 是一个动态值，每个指令处于流水线不同阶段有不同的 Tnew值；
  >     - 一个指令在一个时刻至多有一个 Tnew值（一个指令至多写一个寄存器）
  >
  >   - **结论**
  >
  >     当 T*use* ≥T*new*，说明需要的数据可以及时算出，可以通过**转发**来解决。
  >
  >     当 T*use* <T*new*，说明需要的数据不能及时算出，必须**阻塞**流水线解决。
  >
  > - **各指令的T*use* ，T*new***
  >
  >   |               | Rs_T*use* | Rt_Tuse | E_T*new* | M_T*new* | W_T*new* |
  >   | ------------- | --------- | ------- | -------- | -------- | -------- |
  >   | R型指令       | 1         | 1       | 1        | 0        | 0        |
  >   | I型指令       | 1         | 1       | 1        | 0        | 0        |
  >   | Lw            | 1         | 0       | 2        | 1        | 0        |
  >   | Sw            | 1         | 2       | 1        | 0        | 0        |
  >   | 跳转 B 型指令 | 0         | 0       | 0        | 0        | 0        |
  >   | 跳转 J 型指令 | 0         | 0       | 0        | 0        | 0        |
  >   | 跳转 R 型指令 | 0         | 0       | 0        | 0        | 0        |
  >
  >   我们知道，当 T*use* ≥T*new* 时，可以通过转发解决；当 T*use* <T*new*必须阻塞流水线。
  >
  >   根据上述的  T*use*和T*new* 的值，我们做出策略矩阵，其中 F 表示转发，S 表示暂停：
  >
  >   ![image-20231112131426278](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20231112131426278.png)
  >
  >   根据上表，可以看出只有四种情况需要阻塞：
  >
  >   -  E_T*new*=2  ,  T*use*=0
  >   -  E_T*new*=1  ,  T*use*=0
  >   -  M_T*new*=1  ,  T*use*=0
  >   -  E_T*new*=2  ,  T*use*=1
  >
  >   除了这四种，剩下的情况就是需要转发的了。在转发中，我们需要特别注意**转发的优先级问题和 rt 域有效性问题**。
  >
  >   **转发的优先级**
  >
  >   - 我们要选择流水线中**靠前的“新鲜”的数据**进行转发
  >
  >   **rt 域有效性问题**
  >
  >   - 指有些指令的 rt 域不是用来表示读寄存器编号的，比如 j 指令没有 rt 域、ori 指令的 rt 域表示写入寄存器的编号，那么我们是否需要对这些指令进行特判呢？答案是不需要。对于 rt 域无效的指令，即使我们转发了相应的数据，也不会影响流水线的正确性，因此**无需特判**。
  >
  >   为解决流水线数据冒险，我们可以单独设计一个冒险控制模块，输入用于判断暂停和转发的 A 和 T 信号，输出暂停和转发的控制信号，下面让我们一起来分析该模块内部的逻辑。
  >
  > - **暂停**
  >
  >   我们可以根据T*use* 和T*new*值的不同组合构造出 4 种暂停信号。当然除了上述 **T 的条件，暂停时还需要满足 A 的条件**（即读寄存器和写寄存器编号相同且不为 0、写寄存器信号有效）。最后总的暂停信号把两个寄存器分别的暂停信号或起来即可。
  >
  >   简单起见，我们约定暂停只发生在 D 级，因此当暂停信号有效时，我们需要保持 D 级流水寄存器，清空 E 级流水寄存器。
  >
  > - **转发**
  >
  >   我们首先要在需要转发的点位放一个多路选择器，可以让 0 路对应原始数据，剩下的路按照数据优先级从低到高排列，然后利用一个转发控制信号选择正确的值。转发控制信号在冒险控制模块内生成，具体的判断条件是：**读寄存器和写寄存器编号相同且不为 0、写寄存器信号有效（A 条件）以及转发流水级 T*new*=0（T 条件，表示此时数据已经准备好了）**。

- #### 解决冒险的流水线实现

  > #### 译码器的实现
  >
  > - 在译码的时候，不能只译码出指令信息，还需要译码出指令相关的 AT 信息。只有译码出了 AT 信息，才可以帮助我们进行流水线的决策。
  > - 采用集中式译码的时候，AT 信息只在 D 级被译码了一次，但是同一个指令的 AT 值在不同的流水线阶段可能会发生变化，所以这就要求我们应当在流水线寄存器中完成流水级间的变化，比如某种实现的 Tnew = max{Next-Tnew-1 , 0} 。也可以不在流水线寄存器中完成，而是开辟一个新的功能单元完成
  > - 对于分布式译码，因为 AT 信息在每个流水线都被译码，所以就不存在传递变化的问题，但是译码器就必须知道自己所在的流水级，才能给出对应的正确的 AT 值。
  >
  > #### 阻塞的实现
  >
  > - 当一个指令到达 D 级后，我们需要将它的T*use*值与后面每一级的 T*new*进行比较（当然还有 A 值的校验），当 T*use* <T*new* 时，我们需要阻塞流水线。
  >
  > - 阻塞的实现需要改造流水线寄存器和 PC ，我们需要让它们具有以下功能：
  >
  >   - 冻结 PC 的值；
  >   - 冻结 D 级流水线寄存器的值；
  >   - 将 E 级流水线寄存器清零（这等价于插入了一个 nop 指令）。
  >
  >   此外，还有一个考虑，就是**复位信号和阻塞信号的优先级问题**。请仔细设计信号的优先级来保证流水线的正确性
  >
  > #### 内部转发的实现
  >
  > - 对 GPR 采用**内部转发**机制.也就是说，当前 GPR 被写入的值会即时反馈到读取端上。
  > - 具体的说，当读寄存器时的地址与同周期写寄存器的地址相同时，我们将读取的内容改为写寄存器的内容，而不是该地址可以索引到的寄存器文件中的值。
  >
  > #### 转发的实现
  >
  > - 当一个指令到达 D 级后，我们需要将它的T*use*值与后面每一级的 T*new*进行比较（当然还有 *A* 值的校验），当 T*use* ≥T*new* 时，我们需要进行转发。
  > - 为了实现转发，我们需要两种多路选择器 MUX，分别对应转发的供给者和需求者
  >   - 这是第一种MUX，输入是流水线寄存器的输出，输出是当前指令对应的写数据。
  >   - 这是第二种 MUX，输入是各级的第一种 MUX 的输出，输出是当前正确（或者可以容忍的错误）的读数据。
  >
  > #### 控制器的实现
  >
  > - 我们解决冒险需要进行 AT 值的比较判断，并需要根据判断的结果产生特定的控制信息。这些功能要求我们丰富我们的控制器，使其可以支持这些功能。
  > - 我们的控制器需要产生的信号包括但不限于**冻结信号，刷新信号，供给者选择器信号，需求者选择器信号**等。



## 具体部件

- ### Controller（控制器，根据 splitter 得到的 6 位 funct 码和 6 位 instr_index 码确定指令的类型并输出对应的控制信号）

  - 控制器的设计，从最基本的层面来说，是一个**译码**的过程，将每一条机器指令中包含的信息，转化为给 CPU 各部分的控制信号

  - assign疯狂赋值

  - 指令的opcode和funct



- ### Datapath

  - PC

    - 初始化，起始地址 0x00003000
    - 同步复位
    - 根据PC_sel确定下一条指令地址

    | 指令   | PC_sel | Next_PC                                     |
    | ------ | ------ | ------------------------------------------- |
    | 无     | 00     | PC+4                                        |
    | branch | 01     | PC + 4 + Shift_out                          |
    | jal    | 10     | {{PC[31 : 28]}, instruction[25:0], {2'b00}} |
    | jr     | 11     | grf(Registe[31])                            |

    

  - IM

    - 根据地址输出指令

    - assign

    - 初始化，起始地址 0x00000000
    - 容量为 4096 × 32bit。

    

  - GRF

    - 寄存器堆
    - 同步复位

    - assign读，always写
    - 初始化
    - 0寄存器特判

    

  - ALU

    - assign疯狂输出
    - zero判定

    

  - DM

    - 注意读写判定
    - assign读，always写
    - 同步复位,复位值为 0x00000000
    - 初始化
    - 容量为 3072 × 32bit

    

  - EXT

    - assign输出
    - 注意拓展类型

    

  - Shift

    - assign输出

    

  - branch

    - assign输出
    - 注意各个跳转指令判定

### 模块

- PC
- IM

- GRF：寄存器相关
  - Reg1,Reg2
  - Wreg
  - Wdata
- ALU：运算
- DM：内存
- EXT：位扩展
- Shift：移位
- Controller：控制器

### 结构图

![image-20231121223103227](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20231121223103227.png)

# 测试方案

见附

# 思考题

1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线冒险的角度思考其原因并给出一个指令序列的例子。

我们为了减少不确定带来的开销将比较操作提前到了D级，这直接导致跳转指令的D_Tuse_rt和D_Tuse_rs为0，又因为Tuse < Tnew 时需阻塞流水线，则跳转指令被阻塞的概率较大，可能会在效率方面与提前判断分支带来的提升抵消，甚至降低效率

```
add $1,$1,$1
beq $1,$2,loop1
nop
...
loop1:
```

2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

因为存在延时槽，在跳转指令执行之后，下一条指令（即地址为pc + 4）也会执行，故若需返回时，应返回 pc + 8 （即再下一条指令），否则位于 pc + 4 的指令又会被执行一次，则会产生错误

3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？

如果从功能部件转发，那么某一级的执行总延迟就会增加，从而影响整条流水线的时序设计，不得不延长时钟周期，总效率反而降低。

4、我们为什么要使用 GPR 内部转发？该如何实现？

GPR内部转发即相当于W级向D级的转发。直接将WD端口的输入通过多选器连接到寄存器堆的输出端口

5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

见上。

6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

- 扩展指令的思路：

  在defination中添加指令的识别和控制信号的宏定义。
  明确扩展指令的所属类型，在Controller中添加该指令的识别操作，并将该指令归类（load,store…），并以此为依据修改（或增添）控制信号的选择逻辑。
  根据扩展指令需执行的操作在各个操作模块中添加相应的操作（和控制指令）。
  若扩展指令存在跨级的操作，还要添加相应的流水级寄存器中添加传递的数据和控制信号。
  最后考虑阻塞和转发信号的修改。(注意Tuse和Tnew)

- 寄存器计算指令(cal_r)：
  在Controller中添加相应的识别和控制操作（主要有ALU的运算选择信号，ALU的操作数选择信号，GRF的写入选择信号）。
  与add等指令形制相同则阻塞转发一般无需修改。

- 立即数运算指令(cal_i):

  在Controller中添加相应的识别和控制操作（主要有ext的立即数扩展信号，ALU的运算选择信号，ALU的操作数选择信号，GRF的写入选择信号）。
  与ori指令形制相同则阻塞转发一般无需修改。

- 写数据存储器指令(store):
  在Controller中添加相应的识别和控制操作（主要有DM的读写模式信号）。
  修改DM模块的读写操作。
  与sw指令形制相同则阻塞转发一般无需修改。

- 读数据存储器指令(load):
  在Controller中添加相应的识别和控制操作（主要有DM的读写模式信号，GRF的写入数据选择和写入地址选择信号）。
  修改DM模块的读写操作。
  与lw指令形制相同则阻塞转发一般无需修改。

- j类型跳转指令（jal,jr）:
  在Controller中添加相应的识别和控制操作（主要有NPC的指令地址更新信号，GRF的写入数据选择和写入地址选择信号）。
  增添NPC模块的地址更新操作和GRF模块的写入操作。
  阻塞转发一般无需修改。（注意j_reg的Tuse_rs = 0）

- b类型跳转指令（branch）
  在Controller中添加相应的识别和控制操作（主要有cmp的比较选择操作，NPC的指令地址更新选择操作）。
  在cmp模块中添加比较操作，NPC模块中添加指令地址更新操作。
  阻塞转发一般无需修改。（注意branch的Tuse_rs = Tuse_rt = 0）

7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。

我采用的分布式译码：每一级都部署一个控制器，负责译出当前级所需控制信号。这种方法较为灵活，“现译现用”有效降低了流水级间传递的信号量，但是需要实例化多个控制器，增加了后续流水级的逻辑复杂度。

我的译码器架构为控制信号驱动型：为每个指令定义一个 wire 型变量，使用或运算描述组合逻辑，对每个控制信号进行单独处理。这种方法在指令数量较多时适用，且代码量易于压缩，缺陷是如错添或漏添了某条指令，很难锁定出现错误的位置。

