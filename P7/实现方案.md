# 设计文档

### 实现CP0

- ##### 各个模块对内部异常的检测

![image-20231130195921791](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20231130195921791.png)

- ##### ExcCode的流水

  > ```
  > F_EXC_AdEL
  > D_EXC_RI
  > E_EXC_AriOv,
  > E_EXC_DMOv
  > M_EXC_AdES = (store) && (ErrAlign || ErrOutOfRange || ErrTimer || M_EXC_DMOv
  > M_EXC_AdEL = (load) && (ErrAlign || ErrOutOfRange || ErrTimer || M_EXC_DMOv
  > ```
  >
  > **如果一条指令出现多个异常以先出现的为准**
  >
  > 对于处于延迟槽中的指令，我们的 EPC 需要在 CP0 中特殊处理，因此当前指令是否在延迟槽内，我们需要新开一个信号 isInDelaySlot 跟着一起流水，另外对于阻塞插入的 nop，PC 值和 isInDelaySlot 都不正确，因此我们需要在 DE 流水线寄存器中特殊处理

- ##### 功能定义

  

  内部主要干两件事，处理异常中断和管理那四个寄存器（我们只需要实现其中 4 个就行，注意还有两个是只读的，写入应该忽略） 

  管理寄存器就跟乘除槽管理 HI 和 LO 一样，开四个寄存器，然后根据 mfc0 和 mtc0 这两条指令处理他们的值就好 

  处理异常时需要干下面几件事： 

  将异常码 ExcCode、是否处于延迟槽中的判断信号 isInDelaySlot 和 当前 PC（如果取指地址异常则传递错误的 PC 值）一直跟着流水线到达 M 级直至提交至 CP0，由 CP0 综合判断分析是否响应该异常 

  如果需要响应该异常，则 CP0 输出 Req 信号置为 1，此时 FD、DE、DM、MW 寄存器响应 Req 信号，清空 Instr，将 PC 值设为 0x4180，然后输入 F 级的 NPC 也被置为 0x4180，下一条指令从 0x4180 开始执行 

  当外设和系统外部输入中断信号时，CP0 同样也会确认是否响应该中断，然后把 Req 置为 1，执行相同的操作。异常中断同时发生则中断优先！ 

  当系统外部输入中断信号时，CP0 还会输出一个 TestIntResponse 信号指示是否响应外部中断信号，如果响应则系统会相应去写 0x7f20 地址，从而时外部中断信号停止（2021 年新增！） 

  还有一件事是关于乘除槽的，如果有异常在乘除槽之前被检出，那么就不执行乘除法，简单来说就是开启乘除槽条件在 Start 为 1 的基础上还要加一个 Req 为 0，这一点看一卡代码就行 

  如果是 eret 指令，那么 EXL 需要置 0，表明当前处于用户态，并没有在处理异常（这时候可以响应别的异常了），对于 eret 指令，我们还需要修改 NPC，因为不管是跳到异常处理程序还是跳回去都需要改变 NPC 的值

  对于新加的两条处理 CP0 寄存器的指令，我没加任何转发，只是做了阻塞

  

- ##### 寄存器规范：

  - CP0 寄存器的初始值均为 0，未实现位始终保持 0。
  - 当进入中断或异常状态时，均需要将 EXL 置为 1，用以屏蔽中断信号（注意《SMRL》中并没有指定进入中断时 EXL 的值）；当退出中断或异常状态时，也均需要将 EXL 置为 0，取消屏蔽中断信号。
  - Cause 寄存器的 IP 域每周期写入 HWint 对应位的值。
  - 当进入中断或异常状态时，需要将受害指令的 PC 写入 EPC。



### 实现桥

连接 计时器0，计时器1，DM三个部件

直接根据地址选择是读内存还是外设，是传给 CPU 外设读出来的数据还是内存的数据 

对于我的设计而言，CPU 仅仅与 Bridge 交互，输出地址、输出数据、输入的数据全部进入 Bridge 里面，然后 Bridge 会根据地址判断到底是往哪里写，又反馈给 CPU 什么数据

![image-20231130205214298](C:\Users\86139\AppData\Roaming\Typora\typora-user-images\image-20231130205214298.png)



### 实现计时器

给的源文件，所以难度就在于看懂它，主要是要注意是30位的地址，连端口的时候注意不要输入一个32位的地址就好了



### 实现mips整体架构（感觉可以先实现这个，然后实现桥会更好）

mips.v 中实例化 CPU，Bridge，TC0 和 TC1 三个模块相互交互 利用这样两句实现写 0x7f20，停止中断使能

### 实现三条指令，实现相关控制信号

- 在 P6 基础上新增了 `mfc0, mtc0, eret, syscall` 四条新指令。
- `eret` 具有跳转的功能但是没有延迟槽，你的设计应该保证 `eret` 的后续指令不被执行。
- `syscall` 指令行为与 MARS 不同，无需实现特定的输入输出功能，只需直接产生异常并进入内核态。

### 中断异常约束

- ##### 异常入口：

  《SMRL》的表 5.1 中定义了 MIPS 的异常入口，但考虑到简化设计以及与 MARS 保持一致，我们只支持 0x4180 一个入口地址，所有异常与中断都将从这里进入。

- ##### 嵌套中断异常：

  本实验不要求支持中断异常嵌套的情况。

- ##### 优先级：

  中断优先级高于异常优先级，即当有异常提交至 CP0 寄存器时，若有中断发生，则硬件应先响应中断，并重新执行受害指令及其后续指令；若没有中断发生，则处理异常。

- ##### 精确异常：

  - 除下面的情况外，对所有中断异常的处理都应遵循精确异常的处理规则。

  - 在进入中断或异常状态时，如果受害指令及其后续指令

    已经改变

    了 MDU 的状态，则无需恢复。假设 CP0 在 M 级，MDU 在 E 级，考虑以下情况：

    - `mult` 在 E 级启动了乘法运算，流水到 M 级时产生了中断，此时无需停止乘法计算，其它乘除法指令同理。
    - `mthi` 在 E 级修改了 HI 寄存器，流水到 M 级时产生了中断，此时无需恢复 HI 寄存器的值，`mtlo` 同理。
    - `mult` 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应开始乘法计算，其它乘除法指令同理。
    - `mthi` 在 E 级，受害指令在 M 级，此时还未改变 MDU 状态，不应修改 HI 寄存器的值，`mtlo` 同理。

- ##### 中断规范：

  - Timer0 输出的中断信号接入 HWInt[0] (最低中断位)，Timer1 输出的中断信号接入 HWInt[1]，来自中断发生器的中断信号接入 HWInt[2]。
  - 规定中断产生时的受害指令为宏观 PC 对应的指令，此时应将宏观 PC 写入 EPC。

- ##### MIPS 微系统需要支持的异常：

  | ExcCode | 助记符  | 描述                                             |
  | :------ | :------ | :----------------------------------------------- |
  | 0       | Int     | 中断。                                           |
  | 4       | AdEL    | 取数或取指时地址错误。                           |
  | 5       | AdES    | 存数时地址错误。                                 |
  | 8       | Syscall | 系统调用。                                       |
  | 10      | RI      | 不认识的（或者非法的）指令码。                   |
  | 12      | Ov      | 自陷形式的整数算术指令（例如 `add`）导致的溢出。 |

- ##### 补充说明：

  - 分支跳转指令无论跳转与否，延迟槽指令为受害指令时 `BD` 均需要置位。
  - 发生取指异常或 `RI` 异常后视为 `nop` 直至提交到 CP0。
  - 跳转到不对齐的地址时，受害指令是 PC 值不正确的指令（即需要向 EPC 写入不对齐的地址）。
  - 对于未知指令的判断仅需考虑 opcode（和 R 型指令的 funct），且仅需判断是否出现在 P7 要求的指令集中，同时保证未知指令的测试用例中 opcode 和 funct 码的组合一定没有在 MARS 的基本指令集中出现。

## Controller

- |              | **cal_r**     | **cal_i**     | **load**         | **store**    | **mult_div** | mf             | mt    | mfc0         | mtc0  | **branch**        | **jal**        | **jr**    | **nop** |
  | ------------ | ------------- | ------------- | ---------------- | ------------ | ------------ | :------------- | ----- | ------------ | ----- | :---------------- | -------------- | --------- | ------- |
  | **RegDst**   | **01(Rd)**    | **00(Rt)**    | **00**           | **x**        | **x**        | **01**         | **x** | **00**       | **x** | **x**             | **10(Reg31)**  | **00**    | **x**   |
  | **MemtoReg** | **000(ALU)**  | **根据指令**  | **001(DM)**      | **x**        | **x**        | **100(HI/LO)** | **x** | **101(CP0)** | **x** | **x**             | **011(Adder)** | **00**    | **x**   |
  | **Regwrite** | **1**         | **1**         | **1**            | **0**        | **0**        | **1**          | **0** | **1**        | **0** | **0**             | **1**          | **0**     | **x**   |
  | **ALUop**    | **根据指令**  | **根据指令**  | **010(加)**      | **010(加)**  | **x**        | **x**          | **x** | **x**        | **x** | **110(减)**       | **x**          | **x**     | **x**   |
  | **ALUsrc**   | **0(Rdata2)** | **1(EXT)**    | **1**            | **1**        | **0**        | **x**          | **x** | **x**        | **x** | **0**             | **x**          | **x**     | **x**   |
  | **Memwrite** | **0**         | **0**         | **0**            | **根据指令** | **0**        | **0**          | **0** | **0**        | **0** | **0**             | **x**          | **x**     | **x**   |
  | **Branch**   | **x**         | **x**         | **x**            | **x**        | **x**        | **x**          | **x** | **x**        | **x** | **1(beq)/4(bne)** | **2(jal)**     | **3(jr)** | **x**   |
  | **EXT**      | **x**         | **01(0扩展)** | **00(符号扩展)** | **00**       | **x**        | **x**          | **x** | **x**        | **x** | **00**            | **00**         | **x**     | **x**   |
  | **Shift**    | **x**         | **根据指令**  | **x**            | **x**        | **x**        | **x**          | **x** | x            | x     | **x**             | **x**          | **x**     | **x**   |

### 新增指令

### mfc0



